{"pages":[{"title":"关于","text":"k_arthur4 异或星人 异或星领主 算法竞赛蒟蒻 ICPC铁牌选手","link":"/about/index.html"}],"posts":[{"title":"CodeForces CGR#1 A B C D E F","text":"A. Parity 题意：给定一个多项式，判断值的奇偶，第 $i$ 项为 $a_i \\cdot b^{k-i} $。 解法一：直接模拟，保持对 $2$ 取模。解法二：判断 $base$ 和最后一项的奇偶性。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int base, k, val, x;int main() { cin &gt;&gt; base &gt;&gt; k; for (int i = 0; i &lt; k; ++i) { cin &gt;&gt; x; val = val * base + x; val %= 2; } cout &lt;&lt; (val &amp; 1 ? \"odd\" : \"even\") &lt;&lt; endl; return 0;} B. Tape 题意：一根木棍，分成大小为 $1$ 的 $m$ 段区间，上有 $n$ 个裂缝，要求使用不超过 $k$ 条胶布覆盖所有裂缝。问最短使用多少胶布。 可以认为有 $n$ 个节点的图，用 $n-k$ 条边连接成 $k$ 个联通块，贪心取前 $n-k$ 个最短的区间，加上必须覆盖的 $n$ 个区间。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int N(1e5 + 10);int n, m, k;int b[N];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; for (int i = 2; i &lt;= n; ++i) pq.push(b[i] - b[i-1] - 1); int ans(n); for (int i = 0; i &lt; n - k; ++i) { ans += pq.top(); pq.pop(); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} C. Meaningless Operations 题意：给定 $a$ 求 $f(a) = \\max_{0 &lt; b &lt; a}{gcd(a \\oplus b, a \\&amp; b)}$ 对 $a$ 的二进制表示中每一位取反，使 $a \\oplus b = 2 ^ n - 1$，$a \\&amp; b = 0$，使两数异或值最大，按位与值等于 $0$，使结果最大化。特例：当 $a$ 为 $2$ 的幂次减 $1$ 时，$b$ 不可取 $0$，贪心取小于 $a$ 的最大因子。 p.s. 内建函数 __builtin_popcountll() 用于统计二进制表示中 $1$ 的个数。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define CaseT int T;cin &gt;&gt; T;for(int cas=0; cas &lt; T; ++cas)using namespace std;int a;int bitn(int x) { int res(0); while(x) res++, x &gt;&gt;= 1; return res;}int main() { CaseT { cin &gt;&gt; a; if (__builtin_popcountll(a) != bitn(a)) { cout &lt;&lt; (1 &lt;&lt; bitn(a)) - 1 &lt;&lt; endl; } else { int ans(1); for (int i = 2; i * i &lt;= a; ++i) if (a % i == 0) { ans = a / i; break; } cout &lt;&lt; ans &lt;&lt; endl; } } return 0;} D. Jongmah 题意：有 $n$ 个数字，有 $2$ 种取法，分别是 $[x,x,x]$ 和 $[x,x+1,x+2]$，问最多能取多少次 考虑DP，通过枚举之前的 $[x,x+1,x+2]$ 取法次数，进行递推。由于取 $x$ 会对后 $2$ 个位置的数产生影响，需要 $2$ 个相邻的状态递推到第 $3$ 个状态。 $f[i][k][t]$ 代表前 $i$ 个数取 $k$ 次 $[i-1,i,i+1]$ 和 $t$ 次 $[i,i+1,i+2]$ 得最大次数$f[i-1][j][k]$ 向 $f[i][k][t]$ 递推。由于如果有连续 $3$ 个数值的个数大于 $3$，则可以都取 $[x,x,x]$，$j,k,t$ 最大枚举到 $2$。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int N(1e6+10);int n, m, x;int c[N], dp[N][3][3];int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; x; c[x]++; } memset(dp, -1, sizeof dp); dp[0][0][0] = 0; for (int i = 1; i &lt;= m + 5; ++i) { for (int j = 0; j &lt;= 2; ++j) { for (int k = 0; k &lt;= 2; ++k) { if (dp[i-1][j][k] == -1) continue; int now = c[i] - j - k; for (int t = 0; t &lt;= min(2, now); ++t) { dp[i][k][t] = max(dp[i][k][t], dp[i-1][j][k] + t + (now - t) / 3); } } } } cout &lt;&lt; dp[m+2][0][0] &lt;&lt; endl; return 0;} E. Magic Stones 题意：一个长度为 $n$ 的 $c$ 数组，可以选择下标 $i$ $(2 \\le i \\le n - 1)$，将 $c_i$ 变为 $c_i’ = c_{i + 1} + c_{i - 1} - c_i$。给定两个数组 $c,t$，问 $c$ 能否通过一定操作变为 $t$。 每次操作，不会影响 $c_{i+1}$ 和 $c_{i-1}$，既不会影响差值。考虑差分数组 $d_1,d_2,\\ldots,d_{n-1}, d_i = c_{i+1} - c_i$。对于在下标 $i$ 上的操作：$d_{i-1}’ = c_i’-c_{i-1} = c_{i + 1} + c_{i - 1} - c_i - c_{i-1} = c_{i+1} - c_i = d_i$$d_i’ = c_{i+1}-c_i’ = c_{i+1}-c_{i + 1} - c_{i - 1} + c_i=c_i - c_{i-1} = d_{i-1}$所以每次操作就是交换差分数组相邻的元素。对两差分数组判断组成是否相同，以及两数组首尾是否相同即可。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N(1e5+5);int n;int c[N], t[N];vector&lt;int&gt;dc, dt;int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) dc.push_back(c[i] - c[i-1]); for (int i = 2; i &lt;= n; ++i) dt.push_back(t[i] - t[i-1]); sort(dc.begin(), dc.end()); sort(dt.begin(), dt.end()); for (int i = 0; i &lt; n-1; ++i) { if (dc[i] != dt[i]) { cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } } if (c[1] != t[1] || c[n] != t[n]) cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; return 0;} F. Nearest Leaf 题意：给定一棵已按DFS序标好序的树，$q$ 次询问，查找要求区间 $[l,r]$ 内，距离节点 $v$ 到最近的叶节点的距离 如果每个查询的 $v$ 相同，用DFS序+线段树直接区间查询即可。单次查询复杂度 $O(\\log n)$。在不同 $v$ 之间，考虑换根，离线处理，维护根到所有叶节点的距离。当从父节点 $u$ 转到儿子 $v$ ，边权为 $w$时，到以 $v$ 为根的子树的节点的距离都减少 $w$，到其它节点的距离都增加 $w$。线段树区间更新复杂度 $O(\\log n)$，换根+回溯最多 $2*n$ 次。总复杂度 $O((n+q)\\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;class T&gt;void tomax(T&amp; a, T b) {a = max(a, b);}template&lt;class T&gt;void tomin(T&amp; a, T b) {a = min(a, b);}const ll INFL(0x3f3f3f3f3f3f3f3f);const int N(5e5+5);struct qry {int id, l, r;};struct segt { struct seg { int l, r; ll mn, lz; void update(ll v) {mn += v; lz += v;} }; #define lc x&lt;&lt;1 #define rc x&lt;&lt;1|1 #define mid ((t[x].l+t[x].r)/2) ll * a; seg t[N&lt;&lt;2]; void modify(ll * arr) {a = arr;} void push_up(int x) {t[x].mn = min(t[lc].mn, t[rc].mn);} void push_down(int x) { ll lz = t[x].lz; t[lc].update(lz); t[rc].update(lz); t[x].lz = 0; } void build(int x, int l, int r) { t[x] = seg({l, r, INFL, 0ll}); if(l == r) { t[x].mn = a[l]; return; } build(lc, l, mid); build(rc, mid+1, r); push_up(x); } void update(int x, int l, int r, ll v) { int L(t[x].l), R(t[x].r); if(l &lt;= L &amp;&amp; R &lt;= r) { t[x].update(v); return; } push_down(x); if(l &lt;= mid) update(lc, l, r, v); if(r &gt; mid) update(rc, l, r, v); push_up(x); } ll query(int x, int l, int r) { int L(t[x].l), R(t[x].r); if(l &lt;= L &amp;&amp; R &lt;= r) return t[x].mn; push_down(x); ll res(INFL); if(l &lt;= mid) tomin(res, query(lc, l, r)); if(r &gt; mid) tomin(res, query(rc, l, r)); return res; }};int n, q;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(N);vector&lt;vector&lt;qry&gt;&gt;qs(N);int ed[N];ll dis[N], ans[N];segt tree;void build(int u, ll d) { ed[u] = u; dis[u] = g[u].size() ? INFL : d; for(auto p:g[u]) { build(p.first, d + p.second); tomax(ed[u], ed[p.first]); }}void dfs(int u) { for(qry q:qs[u]) ans[q.id] = tree.query(1, q.l, q.r); for(auto p:g[u]) { int v(p.first), w(p.second); tree.update(1, v, ed[v], -2*w); tree.update(1, 1, n, w); dfs(v); tree.update(1, v, ed[v], 2*w); tree.update(1, 1, n, -w); }}int main() { scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 2; i &lt;= n; ++i) { int fa, cost; scanf(\"%d%d\", &amp;fa, &amp;cost); g[fa].push_back({i,cost}); } for (int i = 1; i &lt;= q; ++i) { int v, l, r; scanf(\"%d%d%d\", &amp;v, &amp;l, &amp;r); qs[v].push_back({i,l,r}); } build(1,0); tree.modify(dis); tree.build(1,1,n); dfs(1); for (int i = 1; i &lt;= q; ++i) printf(\"%I64d\\n\", ans[i]); return 0;}","link":"/2019/02/23/CF-CGR-1/"}],"tags":[{"name":"CF Rounds","slug":"CF-Rounds","link":"/tags/CF-Rounds/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"差分","slug":"差分","link":"/tags/差分/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"比赛题解","slug":"ACM/比赛题解","link":"/categories/ACM/比赛题解/"}]}