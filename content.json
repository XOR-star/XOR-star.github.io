{"pages":[{"title":"关于","text":"k_arthur4 异或星人 异或星领主 算法竞赛蒟蒻 ICPC铁牌选手","link":"/about/index.html"}],"posts":[{"title":"CodeForces #539 partial solutions","text":"2A. Sasha and His Trip 题意：$n$ 个城市排成一行，两两之间距离为 $1$ 公里，从 $1$ 到 $n$ 编号。Sasha 要从 $1$ 号城市开车到 $n$ 号城市，每 $1$ 公里消耗 $1$ 升的油。车的油箱共 $v$ 升，第 $i$ 个城市的油价为 $i$ 元每升。问最少花多少邮费能够到达城市 $n$。 贪心，在城市 $1​$ 尽量加满，之后每到 $1​$ 个城市加一次油，直到可以到达 $n​$ 为止。计算等差数列。注意 $n-1 \\le v​$ 的情况。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, v, ans; cin &gt;&gt; n &gt;&gt; v; if (n - 1 &lt;= v) { ans = n - 1; } else { ans = v; n -= v + 1; ans += (2 + (2 + n - 1)) * n / 2; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 2B. Sasha and Magnetic Machines 题意：给定一个长为 $n$ 的数组 $a$，选择 $1$ 个元素 $a_i$，将其除以它的一个因子 $x$，并将另一个元素 $a_j$ 乘以 $x$。求如此操作可能得到的最小的数组的权值和。 要使权值和最小，要贪心将 $x$ 乘到最小的元素上，由于 $a_i \\le 100$，暴力枚举其它元素的因子，模拟，计算最小值。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int N(5e4 + 10);int n, sum, d;int a[N];int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; ++i) sum += a[i]; sort(a, a+n); d = 0; for (int i = 1; i &lt; n; ++i) { for (int j = 1; j &lt;= a[i]; ++j) { if (a[i] % j == 0) { d = min(d, a[0] * (j - 1) - a[i] / j * (j - 1)); } } } cout &lt;&lt; sum + d &lt;&lt; endl; return 0;} 1A. Sasha and a Bit of Relax 题意：给定一个长为 $n$ 的数组，计算符合条件的区间 $[l,r]$ 个数。要求如下： $r-l+1$ 是偶数 令 $mid=\\frac{l+r-1}{2}$，满足 $a_l \\oplus a_{l+1} \\oplus \\ldots \\oplus a_{mid} = a_{mid + 1} \\oplus a_{mid + 2} \\oplus \\ldots \\oplus a_r $。 考率异或的性质 $x \\oplus x = 0$，区间的两边的异或和相等，可以得出整个区间的异或和等于 $0$。甚至可以获得结论：如果区间 $[l,r]$ 的异或和等于 $0$，那么取区间中任意一个下标 $t$，满足 $$a_l \\oplus a_{l+1} \\oplus \\ldots \\oplus a_{t} = a_{t+ 1} \\oplus a_{t+ 2} \\oplus \\ldots \\oplus a_r $$ 本题的解法，利用前缀异或和的性质，计算到第 $i$ 个元素的时候，前缀异或和等于 $s$，记录前 $i-1$ 个中与 $i$ 同奇偶的下标的前缀异或和为 $s$ 的个数。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int N(3e5 + 10);int n, a[N];map&lt;int, int&gt; odd, even;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; long long ans(0), esum(0); odd[esum]++; for (int i = 0; i &lt; n; ++i) { esum ^= a[i]; ans += i &amp; 1 ? odd[esum] : even[esum]; i &amp; 1 ? odd[esum]++ : even[esum]++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 1B. Sasha and One More Name 题意：给定一个回文串，可以切割 $k$ 次将其变为 $k+1$ 段，问能否将这 $k+1$ 段的顺序重组，将其变成一个与原串不同的回文串。如果可以，输出最小的 $k$。 先考虑不行的情况，一种是所有字符相同；第二种情况，如果字符串长度为奇数，除了回文中心外所有字符都相同，那么唯一不同的那个字符只能做回文中心，以上两种情况无论如何重组，都与原串相同。 如果可以重组，那么至多只要切割 $2$ 次，策略是切割出最短的不同的前缀和后缀，然后交换前后缀的位置，可以保证与原串不同，且依然是回文串。 $1$ 次的情况，暴力模拟即可，不断的对字符串进行 $rotate$ (旋转) 操作，相当于将一段前缀放到后面，然后判断回文。时间复杂度 $O(n^2)$。 P.S. $rotate$ 可以使用 STL 里的 $rotate$ 函数。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;bool checkPal(const string&amp; s) { for (int i = 0, j = s.size() - 1; i &lt; j; ++i, --j) if (s[i] != s[j]) return false; return true;}bool checkAllSame(const string&amp; s) { for (int i = 0; i &lt; (int)s.size() - 1; ++i) if (s[i] != s[i+1]) return false; return true;}void rotate(string&amp; s) { s = s.substr(1) + s[0];}int main() { string s; cin &gt;&gt; s; string t = s; if(t.size() &amp; 1) t.erase(t.size() / 2, 1); if(checkAllSame(t)) { cout &lt;&lt; \"Impossible\" &lt;&lt; endl; return 0; } t = s; for (int i = 0; i &lt; s.size(); ++i) { rotate(t); if (checkPal(t) &amp;&amp; t != s) { cout &lt;&lt; 1 &lt;&lt; endl; return 0; } } cout &lt;&lt; 2 &lt;&lt; endl; return 0;}","link":"/2019/02/27/CF-539/"},{"title":"CodeForces #538","text":"A. Got Any Grapes? 题意：有 $3$ 个人，$A$ 只吃绿葡萄，$D$ 只吃绿葡萄和紫葡萄，$M$ 三种葡萄都吃。$A,D,M$ 分别想吃 $x,y,z$ 个葡萄，现在分别有 $a,b,c$ 个绿、紫、黑葡萄。问是否能合理分配满足所有人的需求。 $A$ 的条件最苛刻，先给 $A$ 分配，再给 $D$，最后给 $M$ 分配。模拟即可。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int x, y, z;int a, b, c;int main() { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a &lt; x) { cout &lt;&lt; \"NO\" &lt;&lt; endl; return 0; } a -= x; if (a + b &lt; y || a + b + c - y &lt; z) { cout &lt;&lt; \"NO\" &lt;&lt; endl; return 0; } cout &lt;&lt; \"YES\" &lt;&lt; endl; return 0;} B. Yet Another Array Partitioning Task 题意：有一个长为 $n$ 的数组，将其分成 $k$ 段长度大于等于 $m$ 的字段，使每个子段的 $beauty$ 值的和最大。输出最大值和分割方式。$beauty$ 值的定义：数组中最大的 $m$ 个数的和。 最后计入答案的数的个数一定等于 $m \\cdot k$，所以值最大的 $m \\cdot k$ 个数的和就是答案，将选中的这些数标记。遍历数组，每遇到 $m$ 个标记过的数字，分出一个子段。一定满足每个子段有 $m$ 个数且答案最大。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int N(2e5 + 5);int n, m, k;int a[N], tag[N];priority_queue&lt;pair&lt;int, int&gt;&gt; pq;vector&lt;int&gt; pos;int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; pq.push({a[i], i}); } long long ans(0); for (int i = 0; i &lt; m * k; ++i) { pair&lt;int, int&gt; pr(pq.top()); pq.pop(); ans += pr.first; tag[pr.second] = 1; } int cnt(0); for (int i = 1; i &lt;= n; ++i) { if (tag[i]) cnt++; if (cnt == m) pos.push_back(i), cnt = 0; } cout &lt;&lt; ans &lt;&lt; endl; for (int i = 0; i &lt; k - 1; ++i) { cout &lt;&lt; pos[i] &lt;&lt; ' '; } return 0;} C. Trailing Loves (or L’oeufs?) 题意：求 $n$ 的阶乘在 $b$ 进制中后缀 $0$ 的个数 如果 $n!$ 在 $b$ 进制下的有 $c$ 个后缀 $0$，那么 $b^c|n!$ 。根据唯一分解定理，$b=p_1^{k_1} \\cdot p_2^{k_2} \\cdot \\ldots \\cdot p_m^{k_m}$，对于每个质数 $p$，其对应指数为 $k$，$n!=C \\cdot p^{t}$，能取到最大 $c’= \\lfloor \\frac{t}{k} \\rfloor$。所以答案 $ans=\\min_{1 \\le i \\le m}{\\lfloor \\frac{t_i}{k_i} \\rfloor}$。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INFL(0x3f3f3f3f3f3f3f3f);ll n, b, ans(INFL);ll cal(ll x, ll c) { ll cnt(0), tmp(n); while(tmp) { cnt += tmp / x; tmp /= x; } return cnt / c;}int main() { cin &gt;&gt; n &gt;&gt; b; int c; for (ll i = 2; i * i &lt;= b; ++i) { if (b % i == 0) { c = 0; while (b % i == 0) b /= i, ++c; ans = min(ans, cal(i, c)); } } if (b &gt; 1) ans = min(ans, cal(b, 1)); cout &lt;&lt; ans &lt;&lt; endl; return 0;} D. Flood Fill 题意：有块长为 $n$ 的木板，每格都被染上颜色。现在可以将连通的同色色块变成任意一种别的颜色，问最少操作几次，将这块木板变为同色。 区间DP，$f[l][r]$ 代表使从 $l$ 到 $r$ 的木板同色的最小次数。$f[l][r]$ 可以由 $f[l+1][r]$ 和 $f[l][r-1]$ 转移得到。当左右两端颜色一样时，可以直接将中间变为同色，并一键合并！$f[l][r] =f[l+1][r-1]+1$，if $a[l]==a[r]$。$f[l][r]=min(f[l+1][r], f[l][r-1]) + 1$，if $a[l] \\neq a[r]$。这里将相邻同色的压缩了，保证相邻不同，不然以下算法会出错。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N(5005);int n;int a[N], f[N][N];int main() { cin &gt;&gt; n; int top = 0, x; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; x; if (x == a[top]) top--; a[++top] = x; } n = top; for (int len = 2; len &lt;= n; ++len) { for (int l = 1; l + len - 1 &lt;= n; ++l) { int r = l + len - 1; if(a[l] == a[r]) f[l][r] = f[l+1][r-1] + 1; else f[l][r] = min(f[l+1][r], f[l][r-1]) + 1; } } cout &lt;&lt; f[1][n] &lt;&lt; endl; return 0;} E. Arithmetic Progression 题意：交互题，有一个长为 $n$ 的数组，将其排序后会是一个等差数列。可以有 $2$ 种询问。 查询 $a_i$ 的值，$0 \\le a_i \\le 10^9$ 查询数组中是否有元素大于 $x$ 要求在不大于 $60$ 次的询问中，计算出排序后数列的最小值和公差 step1 用二分可以通过 $30$ 次查询二得到数列得最大值。step2 访问 $30$ 次随机数组元素，所有其与最大值的差的最大公因数，就是公差。 详细证明可以参考这里，还要用到莫比乌斯反演…我是看不懂2333…本人的虾证明：假设每次step2询问的与最大值的差为 $k \\cdot d$，$d$ 是公差。最终得到的结果$res=gcd(k_1,k_2,\\ldots ,k_{30}) \\cdot d, (1\\le k_i \\le n-1)$。最坏的情况，所有的 $k$ 均是 $2$ 的倍数，那么得到的 $res = 2d$，发生这种情况的概率为 $\\frac{1}{2^{30}}$，这个概率非常非常小。而且只要出现 $2$ 个互质的数，$res$ 一定等于 $1$。所以方法成立，嘻嘻。 P.S. 普通 srand() 最大随机出 $32767$，这里要用 茅台一九九三七，能生成 $int$ 范围内的随机数。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int n;int main() { cin &gt;&gt; n; int mx, l(0), r(1e9+1), mid, ask, reply; for (int i = 0; i &lt; 30; ++i) { mid = ((l + r) / 2); cout &lt;&lt; \"&gt; \" &lt;&lt; mid &lt;&lt; endl; cin &gt;&gt; reply; if(reply) l = mid; else r = mid; } mx = r; int d(0); mt19937 rnd; for (int i = 0; i &lt; 30; ++i) { ask = rnd() % n + 1; cout &lt;&lt; \"? \" &lt;&lt; ask &lt;&lt; endl; cin &gt;&gt; reply; d = __gcd(d, mx - reply); } cout &lt;&lt; \"! \" &lt;&lt; mx - (n - 1) * d &lt;&lt; ' ' &lt;&lt; d &lt;&lt; endl; return 0;} F. Please, another Queries on Array? 题意：给定一个数组，完成2种操作： 将区间 $[l,r]$ 中每个数都乘以 $x$。 对于区间 [l,r] ，求 $\\varphi(\\prod \\limits_{i=l}^{r} a_i)$ ，对 10^9+7 取模。 操作 $1$ 可以用线段树维护，并且获得区间乘积。欧拉函数的公式：$\\varphi(n)=n\\prod\\limits_{p|n}(1-\\frac{1}{p})$，$p$ 为 $n$ 的所有质因子。操作 $2$，只要能够获得区间所有数的质因子就可以实现。由于 $x$ 和 $a_i$ 最大值为 $300$，$300$ 以内的质数个数正好是 $62$，便可以二进制压缩于一个 $long long$ 型整数中，利用按位或运算在线段树上维护。预处理出 $300$ 以内的质数，以及每个数所含质因子的二进制压缩后的值。线段树通过打懒惰标记维护区间乘积和区间或，复杂度为$O(q \\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD(1e9 + 7);const int N(4e5 + 10);const int M(310);ll qpow(ll a, ll n, ll mod = MOD) { ll res(1); while(n) { if(n &amp; 1) (res *= a) %= mod; (a *= a) %= mod; n &gt;&gt;= 1; } return res;}bool prime(int x) { for (int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return 0; return x != 1;}struct seg { int l, r; ll pro, plz; ll fac, flz; void update(ll p, ll f);};int n, q, l, r, x;int a[N];ll bin[M], inv[M];char op[10];seg t[N&lt;&lt;2];vector&lt;int&gt; pris;void init() { for (int i = 2; i &lt;= 300; ++i) inv[i] = qpow(i, MOD-2); for (int i = 2; i &lt;= 300; ++i) if (prime(i)) pris.push_back(i); for (int i = 0; i &lt; 62; ++i) for (int j = 2; j &lt;= 300; ++j) if (j % pris[i] == 0) bin[j] |= (1ll&lt;&lt;i);}void seg::update(ll p, ll f) { (pro *= qpow(p, r - l + 1)) %= MOD; (plz *= p) %= MOD; fac |= f; flz |= f;}#define lc x &lt;&lt; 1#define rc x &lt;&lt; 1 | 1#define mid ((t[x].l + t[x].r) / 2)void push_up(int x) { t[x].pro = (t[lc].pro * t[rc].pro) % MOD; t[x].fac = t[lc].fac | t[rc].fac;}void push_down(int x) { ll &amp;p = t[x].plz, &amp;f = t[x].flz; t[lc].update(p, f); t[rc].update(p, f); p = 1, f = 0;}void build(int x, int l, int r) { t[x] = seg({l, r, 1, 1, 0, 0}); if(l == r) { t[x].update(a[l], bin[a[l]]); return; } build(lc, l, mid); build(rc, mid+1, r); push_up(x);}void update(int x, int l, int r, int v) { int L(t[x].l), R(t[x].r); if(l &lt;= L &amp;&amp; R &lt;= r) { t[x].update(v, bin[v]); return; } push_down(x); if(l &lt;= mid) update(lc, l, r, v); if(r &gt; mid) update(rc, l, r, v); push_up(x);}pair&lt;ll, ll&gt; query(int x, int l, int r) { int L(t[x].l), R(t[x].r); if(l &lt;= L &amp;&amp; R &lt;= r) return make_pair(t[x].pro, t[x].fac); push_down(x); pair&lt;ll, ll&gt; lpr({1, 0}), rpr({1, 0}); if(l &lt;= mid) lpr = query(lc, l, r); if(r &gt; mid) rpr = query(rc, l, r); push_up(x); return make_pair((lpr.first * rpr.first) % MOD, lpr.second | rpr.second);}ll getans(int l, int r) { pair&lt;ll, ll&gt; pr = query(1, l, r); ll ans(pr.first), b(pr.second); for (int i = 0; i &lt; 62; ++i) if(b &amp; (1ll&lt;&lt;i)) { (ans *= inv[pris[i]]) %= MOD; (ans *= pris[i] - 1) %= MOD; } return ans;}int main() { init(); scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); build(1, 1, n); for (int i = 0; i &lt; q; ++i) { scanf(\"%s\", op); scanf(\"%d%d\", &amp;l, &amp;r); if(op[0] == 'M') { scanf(\"%d\", &amp;x); update(1, l, r, x); } else { printf(\"%I64d\\n\", getans(l, r)); } } return 0;}","link":"/2019/02/26/CF-538/"},{"title":"Codeforces Global Round #1 partial solutions","text":"A. Parity 题意：给定一个多项式，判断值的奇偶，第 $i$ 项为 $a_i \\cdot b^{k-i} $。 解法一：直接模拟，保持对 $2$ 取模。解法二：判断 $base$ 和最后一项的奇偶性。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int base, k, val, x;int main() { cin &gt;&gt; base &gt;&gt; k; for (int i = 0; i &lt; k; ++i) { cin &gt;&gt; x; val = val * base + x; val %= 2; } cout &lt;&lt; (val &amp; 1 ? \"odd\" : \"even\") &lt;&lt; endl; return 0;} B. Tape 题意：一根木棍，分成大小为 $1$ 的 $m$ 段区间，上有 $n$ 个裂缝，要求使用不超过 $k$ 条胶布覆盖所有裂缝。问最短使用多少胶布。 可以认为有 $n$ 个节点的图，用 $n-k$ 条边连接成 $k$ 个联通块，贪心取前 $n-k$ 个最短的区间，加上必须覆盖的 $n$ 个区间。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int N(1e5 + 10);int n, m, k;int b[N];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; for (int i = 2; i &lt;= n; ++i) pq.push(b[i] - b[i-1] - 1); int ans(n); for (int i = 0; i &lt; n - k; ++i) { ans += pq.top(); pq.pop(); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} C. Meaningless Operations 题意：给定 $a$ 求 $f(a) = \\max_{0 &lt; b &lt; a}{gcd(a \\oplus b, a \\&amp; b)}$ 对 $a$ 的二进制表示中每一位取反，使 $a \\oplus b = 2 ^ n - 1$，$a \\&amp; b = 0$，使两数异或值最大，按位与值等于 $0$，使结果最大化。特例：当 $a$ 为 $2$ 的幂次减 $1$ 时，$b$ 不可取 $0$，贪心取小于 $a$ 的最大因子。 p.s. 内建函数 __builtin_popcountll() 用于统计二进制表示中 $1$ 的个数。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define CaseT int T;cin &gt;&gt; T;for(int cas=0; cas &lt; T; ++cas)using namespace std;int a;int bitn(int x) { int res(0); while(x) res++, x &gt;&gt;= 1; return res;}int main() { CaseT { cin &gt;&gt; a; if (__builtin_popcountll(a) != bitn(a)) { cout &lt;&lt; (1 &lt;&lt; bitn(a)) - 1 &lt;&lt; endl; } else { int ans(1); for (int i = 2; i * i &lt;= a; ++i) if (a % i == 0) { ans = a / i; break; } cout &lt;&lt; ans &lt;&lt; endl; } } return 0;} D. Jongmah 题意：有 $n$ 个数字，有 $2$ 种取法，分别是 $[x,x,x]$ 和 $[x,x+1,x+2]$，问最多能取多少次 考虑DP，通过枚举之前的 $[x,x+1,x+2]$ 取法次数，进行递推。由于取 $x$ 会对后 $2$ 个位置的数产生影响，需要 $2$ 个相邻的状态递推到第 $3$ 个状态。 $f[i][k][t]$ 代表前 $i$ 个数取 $k$ 次 $[i-1,i,i+1]$ 和 $t$ 次 $[i,i+1,i+2]$ 得最大次数$f[i-1][j][k]$ 向 $f[i][k][t]$ 递推。由于如果有连续 $3$ 个数值的个数大于 $3$，则可以都取 $[x,x,x]$，$j,k,t$ 最大枚举到 $2$。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int N(1e6 + 10);int n, m, x;int c[N], dp[N][3][3];int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; x; c[x]++; } memset(dp, -1, sizeof dp); dp[0][0][0] = 0; for (int i = 1; i &lt;= m + 5; ++i) { for (int j = 0; j &lt;= 2; ++j) { for (int k = 0; k &lt;= 2; ++k) { if (dp[i-1][j][k] == -1) continue; int now = c[i] - j - k; for (int t = 0; t &lt;= min(2, now); ++t) { dp[i][k][t] = max(dp[i][k][t], dp[i-1][j][k] + t + (now - t) / 3); } } } } cout &lt;&lt; dp[m+2][0][0] &lt;&lt; endl; return 0;} E. Magic Stones 题意：一个长度为 $n$ 的 $c$ 数组，可以选择下标 $i$ $(2 \\le i \\le n - 1)$，将 $c_i$ 变为 $c_i’ = c_{i + 1} + c_{i - 1} - c_i$。给定两个数组 $c,t$，问 $c$ 能否通过一定操作变为 $t$。 每次操作，不会影响 $c_{i+1}$ 和 $c_{i-1}$，既不会影响差值。考虑差分数组 $d_1,d_2,\\ldots,d_{n-1}, d_i = c_{i+1} - c_i$。对于在下标 $i$ 上的操作：$d_{i-1}’ = c_i’-c_{i-1} = c_{i + 1} + c_{i - 1} - c_i - c_{i-1} = c_{i+1} - c_i = d_i$$d_i’ = c_{i+1}-c_i’ = c_{i+1}-c_{i + 1} - c_{i - 1} + c_i=c_i - c_{i-1} = d_{i-1}$所以每次操作就是交换差分数组相邻的元素。对两差分数组判断组成是否相同，以及两数组首尾是否相同即可。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N(1e5 + 5);int n;int c[N], t[N];vector&lt;int&gt;dc, dt;int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) dc.push_back(c[i] - c[i-1]); for (int i = 2; i &lt;= n; ++i) dt.push_back(t[i] - t[i-1]); sort(dc.begin(), dc.end()); sort(dt.begin(), dt.end()); for (int i = 0; i &lt; n-1; ++i) { if (dc[i] != dt[i]) { cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } } if (c[1] != t[1] || c[n] != t[n]) cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; return 0;} F. Nearest Leaf 题意：给定一棵已按DFS序标好序的树，$q$ 次询问，查找要求区间 $[l,r]$ 内，距离节点 $v$ 到最近的叶节点的距离 如果每个查询的 $v$ 相同，用DFS序+线段树直接区间查询即可。单次查询复杂度 $O(\\log n)$。在不同 $v$ 之间，考虑换根，离线处理，维护根到所有叶节点的距离。当从父节点 $u$ 转到儿子 $v$ ，边权为 $w$时，到以 $v$ 为根的子树的节点的距离都减少 $w$，到其它节点的距离都增加 $w$。线段树区间更新复杂度 $O(\\log n)$，换根+回溯最多 $2*n$ 次。总复杂度 $O((n+q)\\log n)$。 题目读懂就好写了，可是没读懂…码力不足，写也来不及555~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;class T&gt;void tomax(T&amp; a, T b) {a = max(a, b);}template&lt;class T&gt;void tomin(T&amp; a, T b) {a = min(a, b);}const ll INFL(0x3f3f3f3f3f3f3f3f);const int N(5e5 + 5);struct qry {int id, l, r;};struct segt { struct seg { int l, r; ll mn, lz; void update(ll v) {mn += v; lz += v;} }; #define lc x&lt;&lt;1 #define rc x&lt;&lt;1|1 #define mid ((t[x].l+t[x].r)/2) ll * a; seg t[N&lt;&lt;2]; void modify(ll * arr) {a = arr;} void push_up(int x) {t[x].mn = min(t[lc].mn, t[rc].mn);} void push_down(int x) { ll lz = t[x].lz; t[lc].update(lz); t[rc].update(lz); t[x].lz = 0; } void build(int x, int l, int r) { t[x] = seg({l, r, INFL, 0ll}); if(l == r) { t[x].mn = a[l]; return; } build(lc, l, mid); build(rc, mid+1, r); push_up(x); } void update(int x, int l, int r, ll v) { int L(t[x].l), R(t[x].r); if(l &lt;= L &amp;&amp; R &lt;= r) { t[x].update(v); return; } push_down(x); if(l &lt;= mid) update(lc, l, r, v); if(r &gt; mid) update(rc, l, r, v); push_up(x); } ll query(int x, int l, int r) { int L(t[x].l), R(t[x].r); if(l &lt;= L &amp;&amp; R &lt;= r) return t[x].mn; push_down(x); ll res(INFL); if(l &lt;= mid) tomin(res, query(lc, l, r)); if(r &gt; mid) tomin(res, query(rc, l, r)); return res; }};int n, q;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(N);vector&lt;vector&lt;qry&gt;&gt; qs(N);int ed[N];ll dis[N], ans[N];segt tree;void build(int u, ll d) { ed[u] = u; dis[u] = g[u].size() ? INFL : d; for(auto p:g[u]) { build(p.first, d + p.second); tomax(ed[u], ed[p.first]); }}void dfs(int u) { for(qry q:qs[u]) ans[q.id] = tree.query(1, q.l, q.r); for(auto p:g[u]) { int v(p.first), w(p.second); tree.update(1, v, ed[v], - 2 * w); tree.update(1, 1, n, w); dfs(v); tree.update(1, v, ed[v], 2 * w); tree.update(1, 1, n, -w); }}int main() { scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 2; i &lt;= n; ++i) { int fa, cost; scanf(\"%d%d\", &amp;fa, &amp;cost); g[fa].push_back({i, cost}); } for (int i = 1; i &lt;= q; ++i) { int v, l, r; scanf(\"%d%d%d\", &amp;v, &amp;l, &amp;r); qs[v].push_back({i, l, r}); } build(1, 0); tree.modify(dis); tree.build(1, 1, n); dfs(1); for (int i = 1; i &lt;= q; ++i) printf(\"%I64d\\n\", ans[i]); return 0;}","link":"/2019/02/23/CF-CGR-1/"}],"tags":[{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"暴力","slug":"暴力","link":"/tags/暴力/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"CF Rounds","slug":"CF-Rounds","link":"/tags/CF-Rounds/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"差分","slug":"差分","link":"/tags/差分/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"比赛题解","slug":"ACM/比赛题解","link":"/categories/ACM/比赛题解/"}]}